---
title: "Go openpgp ì°¸ê³  ì‚¬í•­"
category: [Go]
toc: true
toc_label: "ì´ í˜ì´ì§€ ëª©ì°¨"
---

Go íŒ¨í‚¤ì§€ ì¤‘ì— `golang.org/x/crypto/openpgp`ì—ì„œ PGP encrypt/decrypt ì‚¬ìš© íŒì´ë‹¤.

## openpgp íŒ¨í‚¤ì§€
Goë¡œ í”„ë¡œê·¸ë˜ë° ì¤‘ì— PGP encrypt/decrypt í•  ì¼ì´ ìƒê²¨ì„œ (ê¸°ì¡´ì— Javaë¡œ êµ¬í˜„í–ˆì„ ë•Œì—ëŠ” [Bouncy Castle](https://www.bouncycastle.org/)ì„ ì´ìš©í–ˆì—ˆìŒ) ê´€ë ¨ íŒ¨í‚¤ì§€ë¥¼ ì°¾ì•„ë³´ë‹ˆ [golang.org/x/crypto/openpgp](https://pkg.go.dev/golang.org/x/crypto/openpgp) íŒ¨í‚¤ì§€ê°€ ìˆì—ˆë‹¤.  
ì´ íŒ¨í‚¤ì§€ëŠ” ê°„ë‹¨í•´ì„œ ì‚¬ìš©í•˜ê¸°ê°€ ì¢‹ì•˜ëŠ”ë°, encrypt/decrypt ì‹œ ì•½ê°„ì˜ ë¬¸ì œê°€ ë°œìƒí•˜ì—¬ ì´ì— ëŒ€í•œ í•´ê²° íŒì„ ê¸°ë¡í•œë‹¤.

## PGP encrypt ì˜ˆì œ
ì•„ë˜ëŠ” openpgp íŒ¨í‚¤ì§€ë¥¼ ì´ìš©í•˜ì—¬ ë‚´ê°€ ì…ë ¥ plain íŒŒì¼ì„ PGP encrypt í•˜ëŠ” ì½”ë“œë¥¼ êµ¬í˜„í•œ ì†ŒìŠ¤ì´ë‹¤. (ì•„ë˜ ì†ŒìŠ¤ì—ì„œ **publicKey** ë³€ìˆ˜ì—ëŠ” ì‹¤ì œë¡œ ì‚¬ìš©í•  PGP public keyë¥¼ ë„£ì–´ì•¼ í•¨, PGP decryptë„ ìœ ì‚¬í•˜ë¯€ë¡œ ë³¸ ê¸€ì—ì„œëŠ” ìƒëµ)
```go
package main
import (
    "bytes"
    "fmt"
    "io"
    "os"
    "golang.org/x/crypto/openpgp"
)
const publicKey = `-----BEGIN PGP PUBLIC KEY BLOCK-----

-----END PGP PUBLIC KEY BLOCK-----`

func main() {
    if len(os.Args) < 2 {
        fmt.Println("No file name to be encrypted")
        return
    }

    // PGP encrypt í•  PGP íŒŒì¼ ì´ë¦„ì„ ì–»ëŠ”ë‹¤.
    fileToEnc := os.Args[1]
    clearFile, err := os.Open(fileToEnc)
    if err != nil {
        fmt.Println(err)
        return
    }
    defer clearFile.Close()

    // Encrypt í•´ì„œ ì €ì¥í•  íŒŒì¼ì„ ìƒì„±í•œë‹¤.
    pgpFile, err := os.Create(fileToEnc + ".pgp")
    if err != nil {
        fmt.Println(err)
        return
    }
    defer pgpFile.Close()

    // ìˆ˜ì‹ ìë“¤ì˜ public keyë¥¼ ì½ëŠ”ë‹¤.
    publicKeys := []string{publicKey}
    entityList, err := readPublicKeys(publicKeys)
    if err != nil {
        fmt.Println("Fail to read public key")
        return
    }

    // PGP íŒŒì¼ì„ encrypt í•˜ì—¬ íŒŒì¼ì— ì €ì¥í•œë‹¤.
    encrypt(entityList, clearFile, pgpFile)
}

// ì…ë ¥ PGP key ë“¤ì„ ì½ì–´ì„œ EntityListë¡œ ë¦¬í„´í•œë‹¤.
func readPublicKeys(keys []string) (openpgp.EntityList, error) {
    var entityLists openpgp.EntityList
    for _, key := range keys {
        entityList, err := openpgp.ReadArmoredKeyRing(strings.NewReader(key))
        if err != nil {
            return entityList, err
        }
        entityLists = append(entityLists, entityList[0])
    }
    return entityLists, nil
}

// ì…ë ¥ clear íŒŒì¼ì„ ì…ë ¥ ìˆ˜ì‹ ì í‚¤ë¡œ encrypt í•˜ì—¬ PGP ì¶œë ¥ íŒŒì¼ì„ ìƒì„±í•œë‹¤.
func encrypt(entityList openpgp.EntityList, r io.Reader, w io.Writer) error {
    // PGP encrypt í•œë‹¤.
    wc, err := openpgp.Encrypt(w, entityList, signer, &openpgp.FileHints{IsBinary: true}, nil)
    if err != nil {
        fmt.Println(err)
        return err
    }

    // íŒŒì¼ì— write í•œë‹¤.
    if _, err := io.Copy(wc, r); err != nil {
        fmt.Println(err)
        return err
    }
    return wc.Close()
}
```

## PGP encryptê°€ ì‹¤íŒ¨í•˜ëŠ” ê²½ìš°
ê·¸ëŸ°ë° ìœ„ ì†ŒìŠ¤ë¡œ PGP encryptë¥¼ í…ŒìŠ¤íŠ¸ í•´ ë³´ë©´, íŠ¹ì •ì¸ì˜ ê²½ìš°ì—ëŠ” encrypt ì‹œì— ì•„ë˜ ë©”ì‹œì§€ë¥¼ ì¶œë ¥í•˜ë©´ì„œ ì‹¤íŒ¨í•˜ì˜€ë‹¤.
> openpgp: invalid argument: cannot encrypt because recipient set shares no common algorithms  

ë˜ëŠ”  
> openpgp: invalid argument: cannot encrypt because no candidate hash functions are compiled in. (Wanted RIPEMD160 in this case.)

ì‹¤íŒ¨í•˜ëŠ” ê²½ìš°ë¥¼ ì‚´í´ë³´ë‹ˆ, PGP keyê°€ 2010ë…„ ì´ì „ì— ë§ì´ ì‚¬ìš©ë˜ë˜ DSA ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ELG ì•”í˜¸ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš°ì˜€ë‹¤.  

ê·¸ë˜ì„œ openpgp íŒ¨í‚¤ì§€ì˜ write.go íŒŒì¼ì—ì„œ Encrypt() í•¨ìˆ˜ë¥¼ í™•ì¸í•´ ë³´ë‹ˆ ì•„ë˜ì™€ ê°™ì´ ë˜ì–´ ìˆì—ˆë‹¤.
```go
candidateHashes := []uint8{
    hashToHashId(crypto.SHA256),
    hashToHashId(crypto.SHA384),
    hashToHashId(crypto.SHA512),
    hashToHashId(crypto.SHA1),
    hashToHashId(crypto.RIPEMD160),
}
```

ì—ëŸ¬ ë©”ì‹œì§€ ì¤‘ì—ì„œ **(Wanted RIPEMD160 in this case.)** ë‚´ìš©ì„ ì°¸ì¡°í•˜ì—¬ ì´ ë¶€ë¶„ì„ ì•„ë˜ì™€ ê°™ì´ ìˆœì„œë¥¼ ì¡°ì •í•˜ì˜€ë”ë‹ˆ, ë”ì´ìƒ PGP encryptê°€ ì‹¤íŒ¨í•˜ì§€ ì•Šê³  ì„±ê³µí•˜ì˜€ë‹¤.
```go
candidateHashes := []uint8{
    hashToHashId(crypto.SHA256),
    hashToHashId(crypto.SHA384),
    hashToHashId(crypto.SHA512),
    hashToHashId(crypto.RIPEMD160),
    hashToHashId(crypto.SHA1),
}
```

ğŸš© ê·¸ëŸ°ë° ìœ„ ë°©ë²•ì€ openpgp íŒ¨í‚¤ì§€ì˜ ì†ŒìŠ¤ë¥¼ ìˆ˜ì •í•´ì•¼ í•˜ë¯€ë¡œ ì¢‹ì€ ë°©ë²•ì€ ì•„ë‹ˆì–´ì„œ, ì¢€ ë” êµ¬ê¸€ë§í•˜ë‹¤ê°€ ì´ëŸ° ê²½ìš°ì— openpgpë¥¼ ì‚¬ìš©í•˜ëŠ” ê³³ì—ì„œ ì•„ë˜ì™€ ê°™ì´ `"golang.org/x/crypto/ripemd160"`ë¥¼ import í•˜ë©´ ëœë‹¤ëŠ” ìë£Œë¥¼ ì°¾ì•˜ë‹¤.
```go
import _ "golang.org/x/crypto/ripemd160"
```
í˜¹ì‹œë‚˜ í•˜ê³  ì‹œë„í•´ ë³´ì•˜ëŠ”ë° ì‹ ê¸°í•˜ê²Œë„ ì´ import ì¶”ê°€ë§Œìœ¼ë¡œ RIPEMD160 ì—ëŸ¬ì—†ì´ encryptê°€ ì„±ê³µí•˜ì˜€ë‹¤. ğŸ¤”

## PGP armor íŒŒì¼ì„ decrypt í•˜ê¸°
Binary PGP íŒŒì¼ì„ decrypt í•˜ëŠ” ê²ƒì€ [openpgp](https://pkg.go.dev/golang.org/x/crypto/openpgp) íŒ¨í‚¤ì§€ë¡œ ì‰½ê²Œ ë˜ëŠ”ë°, ASCII PGP íŒŒì¼ì€ decryptê°€ ë˜ì§ˆ ì•Šì•˜ë‹¤.
> ASCII PGP íŒŒì¼ì€ `-----BEGIN PGP MESSAGE-----` ë¬¸ìì—´ë¡œ ì‹œì‘í•´ì„œ `-----END PGP MESSAGE-----` ë¬¸ìì—´ë¡œ ëë‚˜ëŠ” ASCII íŒŒì¼ì´ë‹¤.

ê·¸ë˜ì„œ ASCII PGP íŒŒì¼ ì—¬ë¶€ë¥¼ **asciiArmored** íŒŒë¼ë¯¸í„°ë¡œ ë°›ì•„ì„œ ì•„ë˜ì™€ ê°™ì´ PGP decrypt í•˜ëŠ” í•¨ìˆ˜ë¥¼ êµ¬í˜„í–ˆë”ë‹ˆ, binary/ascii ë‘˜ ë‹¤ decryptê°€ ì˜ ë˜ì—ˆë‹¤. ğŸ˜›
```go
func pgpDecrypt(asciiArmored bool, entityList openpgp.EntityList, r io.Reader, w io.Writer) error {
    entity := entityList[0]

    // Private key ì•”í˜¸ë¥¼ ì„¸íŒ…í•œë‹¤.
    passphraseByte := []byte(myPrivatePw)
    entity.PrivateKey.Decrypt(passphraseByte)
    for _, subkey := range entity.Subkeys {
        subkey.PrivateKey.Decrypt(passphraseByte)
    }

    // PGP decrypt í•œë‹¤.
    pgpBodyReader := r
    if asciiArmored == true {
        block, err := armor.Decode(r)
        if err != nil {
            return err
        }
        pgpBodyReader = block.Body
    }
    md, err := openpgp.ReadMessage(pgpBodyReader, entityList, nil, nil)
    if err != nil {
        return err
    }

    // Decrypt ëœ ë©”ì‹œì§€ë¥¼ ì¶œë ¥ íŒŒì¼ì— write í•œë‹¤.
    _, err = io.Copy(w, md.UnverifiedBody)
    return err
}
```
